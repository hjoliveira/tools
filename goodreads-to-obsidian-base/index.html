<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goodreads to Obsidian Converter</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        h1 {
            color: #a855f7;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #a855f7;
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(168, 85, 247, 0.05);
        }
        .upload-area:hover {
            background: rgba(168, 85, 247, 0.1);
            border-color: #c084fc;
        }
        .upload-area.dragover {
            background: rgba(168, 85, 247, 0.15);
            border-color: #c084fc;
        }
        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        .upload-text {
            font-size: 18px;
            margin-bottom: 10px;
        }
        .upload-hint {
            color: #888;
            font-size: 14px;
        }
        input[type="file"] {
            display: none;
        }
        #status {
            margin-top: 30px;
            padding: 20px;
            border-radius: 8px;
            display: none;
        }
        #status.success {
            display: block;
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid #22c55e;
            color: #22c55e;
        }
        #status.error {
            display: block;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            color: #ef4444;
        }
        #status.processing {
            display: block;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid #a855f7;
            color: #c084fc;
        }
        .book-count {
            font-weight: bold;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <h1>Goodreads to Obsidian Converter</h1>
    <p class="subtitle">Convert your Goodreads library export to Obsidian markdown files</p>

    <div class="upload-area" id="dropZone">
        <div class="upload-icon">ðŸ“š</div>
        <div class="upload-text">Drop your Goodreads CSV file here</div>
        <div class="upload-hint">or click to browse</div>
        <input type="file" id="fileInput" accept=".csv">
    </div>

    <div id="status"></div>

    <script>
        // Pure JavaScript ZIP creator (no external dependencies)
        const ZipCreator = {
            crc32Table: null,

            initCRC32() {
                if (this.crc32Table) return;
                this.crc32Table = new Uint32Array(256);
                for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let j = 0; j < 8; j++) {
                        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                    }
                    this.crc32Table[i] = c;
                }
            },

            crc32(data) {
                this.initCRC32();
                let crc = 0xFFFFFFFF;
                for (let i = 0; i < data.length; i++) {
                    crc = this.crc32Table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
                }
                return (crc ^ 0xFFFFFFFF) >>> 0;
            },

            createZip(files) {
                const localFiles = [];
                const centralDir = [];
                let offset = 0;

                for (const file of files) {
                    const nameBytes = new TextEncoder().encode(file.name);
                    const contentBytes = new TextEncoder().encode(file.content);
                    const crc = this.crc32(contentBytes);

                    // Local file header
                    const localHeader = new Uint8Array(30 + nameBytes.length);
                    const localView = new DataView(localHeader.buffer);

                    localView.setUint32(0, 0x04034B50, true);  // Signature
                    localView.setUint16(4, 20, true);          // Version needed
                    localView.setUint16(6, 0, true);           // Flags
                    localView.setUint16(8, 0, true);           // Compression (store)
                    localView.setUint16(10, 0, true);          // Mod time
                    localView.setUint16(12, 0, true);          // Mod date
                    localView.setUint32(14, crc, true);        // CRC-32
                    localView.setUint32(18, contentBytes.length, true); // Compressed size
                    localView.setUint32(22, contentBytes.length, true); // Uncompressed size
                    localView.setUint16(26, nameBytes.length, true);    // Filename length
                    localView.setUint16(28, 0, true);          // Extra field length
                    localHeader.set(nameBytes, 30);

                    localFiles.push(localHeader, contentBytes);

                    // Central directory entry
                    const centralEntry = new Uint8Array(46 + nameBytes.length);
                    const centralView = new DataView(centralEntry.buffer);

                    centralView.setUint32(0, 0x02014B50, true);  // Signature
                    centralView.setUint16(4, 20, true);          // Version made by
                    centralView.setUint16(6, 20, true);          // Version needed
                    centralView.setUint16(8, 0, true);           // Flags
                    centralView.setUint16(10, 0, true);          // Compression
                    centralView.setUint16(12, 0, true);          // Mod time
                    centralView.setUint16(14, 0, true);          // Mod date
                    centralView.setUint32(16, crc, true);        // CRC-32
                    centralView.setUint32(20, contentBytes.length, true); // Compressed size
                    centralView.setUint32(24, contentBytes.length, true); // Uncompressed size
                    centralView.setUint16(28, nameBytes.length, true);    // Filename length
                    centralView.setUint16(30, 0, true);          // Extra field length
                    centralView.setUint16(32, 0, true);          // Comment length
                    centralView.setUint16(34, 0, true);          // Disk number
                    centralView.setUint16(36, 0, true);          // Internal attrs
                    centralView.setUint32(38, 0, true);          // External attrs
                    centralView.setUint32(42, offset, true);     // Offset to local header
                    centralEntry.set(nameBytes, 46);

                    centralDir.push(centralEntry);
                    offset += localHeader.length + contentBytes.length;
                }

                // End of central directory
                const centralDirSize = centralDir.reduce((sum, e) => sum + e.length, 0);
                const endRecord = new Uint8Array(22);
                const endView = new DataView(endRecord.buffer);

                endView.setUint32(0, 0x06054B50, true);   // Signature
                endView.setUint16(4, 0, true);            // Disk number
                endView.setUint16(6, 0, true);            // Central dir disk
                endView.setUint16(8, files.length, true); // Entries on disk
                endView.setUint16(10, files.length, true);// Total entries
                endView.setUint32(12, centralDirSize, true); // Central dir size
                endView.setUint32(16, offset, true);      // Central dir offset
                endView.setUint16(20, 0, true);           // Comment length

                // Combine all parts
                const allParts = [...localFiles, ...centralDir, endRecord];
                const totalSize = allParts.reduce((sum, p) => sum + p.length, 0);
                const result = new Uint8Array(totalSize);

                let pos = 0;
                for (const part of allParts) {
                    result.set(part, pos);
                    pos += part.length;
                }

                return new Blob([result], { type: 'application/zip' });
            }
        };

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');

        // Click to upload
        dropZone.addEventListener('click', () => fileInput.click());

        // Drag and drop handlers
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });

        function showStatus(message, type) {
            status.textContent = message;
            status.className = type;
        }

        function parseCSV(text) {
            const lines = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const char = text[i];

                if (char === '"') {
                    if (inQuotes && text[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (current.trim() || lines.length > 0) {
                        lines.push(current);
                    }
                    current = '';
                    if (char === '\r' && text[i + 1] === '\n') {
                        i++;
                    }
                } else {
                    current += char;
                }
            }

            if (current.trim()) {
                lines.push(current);
            }

            return lines.map(line => {
                const fields = [];
                let field = '';
                let inFieldQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        if (inFieldQuotes && line[i + 1] === '"') {
                            field += '"';
                            i++;
                        } else {
                            inFieldQuotes = !inFieldQuotes;
                        }
                    } else if (char === ',' && !inFieldQuotes) {
                        fields.push(field);
                        field = '';
                    } else {
                        field += char;
                    }
                }
                fields.push(field);

                return fields;
            });
        }

        function sanitizeFilename(title) {
            // Remove or replace characters that are invalid in filenames
            return title
                .replace(/[<>:"/\\|?*]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function escapeYamlValue(value) {
            if (!value) return '';
            // If value contains special characters, wrap in quotes
            if (value.includes(':') || value.includes('#') || value.includes('\n') ||
                value.includes('"') || value.startsWith(' ') || value.endsWith(' ')) {
                return '"' + value.replace(/"/g, '\\"') + '"';
            }
            return value;
        }

        function createMarkdownContent(headers, row) {
            let frontmatter = '---\n';

            for (let i = 0; i < headers.length; i++) {
                const header = headers[i].trim();
                let value = (row[i] || '').trim();

                // Skip Book Id as it's internal to Goodreads
                if (header === 'Book Id') continue;

                // Clean up ISBN values (remove ="")
                if (value.startsWith('="') && value.endsWith('"')) {
                    value = value.slice(2, -1);
                }

                // Format the header for YAML (keep spaces for readability)
                const yamlKey = header;
                const yamlValue = escapeYamlValue(value);

                frontmatter += `${yamlKey}: ${yamlValue}\n`;
            }

            frontmatter += '---\n#book\n';

            return frontmatter;
        }

        async function processFile(file) {
            if (!file.name.endsWith('.csv')) {
                showStatus('Please upload a CSV file', 'error');
                return;
            }

            showStatus('Processing your library...', 'processing');

            try {
                const text = await file.text();
                const rows = parseCSV(text);

                if (rows.length < 2) {
                    showStatus('CSV file appears to be empty or invalid', 'error');
                    return;
                }

                const headers = rows[0];
                const titleIndex = headers.findIndex(h => h.trim().toLowerCase() === 'title');

                if (titleIndex === -1) {
                    showStatus('Could not find Title column in CSV', 'error');
                    return;
                }

                const zipFiles = [];
                let bookCount = 0;

                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    if (row.length < 2) continue; // Skip empty rows

                    const title = row[titleIndex];
                    if (!title || !title.trim()) continue;

                    const filename = sanitizeFilename(title) + '.md';
                    const content = createMarkdownContent(headers, row);

                    zipFiles.push({ name: filename, content: content });
                    bookCount++;
                }

                if (bookCount === 0) {
                    showStatus('No books found in the CSV file', 'error');
                    return;
                }

                const blob = ZipCreator.createZip(zipFiles);

                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'obsidian-books.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus(`Successfully converted ${bookCount} books! Download started.`, 'success');

            } catch (error) {
                console.error(error);
                showStatus('Error processing file: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>
